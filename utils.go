package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Convert a wildcard pattern to a regular expression
func wildcardToRegex(pattern string) string {
	pattern = strings.ReplaceAll(pattern, ".", "\\.") // Escape dots
	pattern = strings.ReplaceAll(pattern, "*", ".*")  // Replace * with .*
	return "^" + pattern + "$"                        // Match the whole string
}

func matchesSyncPattern(filePath string) bool {
	for _, pattern := range syncConfig.Patterns {
		// Convert wildcard pattern to regex
		regexPattern := wildcardToRegex(pattern)
		matched, _ := regexp.MatchString(regexPattern, filePath)
		if matched {
			return true
		}
	}
	return false
}

// Update the .gitignore file by replacing the SYNCWAVE SECTION with the sync patterns
func updateGitIgnore(files []string) error {
	// Read the current .gitignore file
	gitIgnore, err := ioutil.ReadFile(".gitignore")
	if err != nil {
		// If the .gitignore file doesn't exist, create it
		if os.IsNotExist(err) {
			gitIgnore = []byte{}
		} else {
			return err
		}
	}

	ignoreContent := string(gitIgnore)

	// Define the section markers for the sync patterns
	sectionStart := "# SYNCWAVE SECTION START"
	sectionEnd := "# SYNCWAVE SECTION END"

	// Generate the new content for the SYNCWAVE section
	newSection := fmt.Sprintf("%s\n# WARNING: This section is generated by the sync app.\n", sectionStart)
	for _, file := range files {
		newSection += file + "\n"
	}
	newSection += sectionEnd + "\n"

	// Regular expression to match the existing SYNCWAVE section
	sectionRegex := regexp.MustCompile(`(?s)# SYNCWAVE SECTION START.*?# SYNCWAVE SECTION END`)

	// Replace the SYNCWAVE section if it exists, or append it if not
	if sectionRegex.MatchString(ignoreContent) {
		ignoreContent = sectionRegex.ReplaceAllString(ignoreContent, newSection)
	} else {
		// If the section doesn't exist, append it at the end of the file
		if !strings.HasSuffix(ignoreContent, "\n") {
			ignoreContent += "\n" // Ensure there's a newline at the end
		}
		ignoreContent += newSection
	}

	// Write the updated content back to the .gitignore file
	return ioutil.WriteFile(".gitignore", []byte(ignoreContent), 0644)
}

func removePreviousZipFiles(branch string) error {
	files, err := ioutil.ReadDir(syncConfig.CloudDir)
	if err != nil {
		return err
	}

	for _, file := range files {
		if strings.HasPrefix(file.Name(), branch+"_") && strings.HasSuffix(file.Name(), ".zstd") {
			err := os.Remove(filepath.Join(syncConfig.CloudDir, file.Name()))
			if err != nil {
				return err
			}
		}
	}

	return nil
}
