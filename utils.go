package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Convert a wildcard pattern to a regular expression
func wildcardToRegex(pattern string) string {
	pattern = strings.ReplaceAll(pattern, ".", "\\.") // Escape dots
	pattern = strings.ReplaceAll(pattern, "*", ".*")  // Replace * with .*
	return "^" + pattern + "$"                        // Match the whole string
}

func matchesSyncPattern(filePath string) bool {
	for _, pattern := range syncConfig.Patterns {
		// Convert wildcard pattern to regex
		regexPattern := wildcardToRegex(pattern)
		matched, _ := regexp.MatchString(regexPattern, filePath)
		if matched {
			return true
		}
	}

	return false
}

func matchesSyncPatternAndCheckFileSize(filePath string) bool {
	matched := matchesSyncPattern(filePath)
	// if !matched {
	// 	return checkFileSize(filePath)
	// }
	return matched
}

// func checkFileSize(filePath string) bool {
// 	fileInfo, err := os.Stat(filePath)
// 	if err != nil {
// 		return false // Skip file if we can't get file info
// 	}

// 	// Convert file size to KB
// 	fileSizeKB := fileInfo.Size() / 1024

// 	// Check if min_file_size_kb is set, and if the file is larger than that
// 	if syncConfig.MinFileSizeKB != nil && fileSizeKB > *syncConfig.MinFileSizeKB {
// 		return true // File is larger than the limit, so it should be added to the archive and gitignore
// 	}
// 	return false
// }

// Update the .gitignore file by replacing the SYNCWAVE SECTION with the sync patterns
func updateGitIgnore() error {
	// Read the current .gitignore file
	gitIgnore, err := ioutil.ReadFile(".gitignore")
	if err != nil {
		// If the .gitignore file doesn't exist, create it
		if os.IsNotExist(err) {
			gitIgnore = []byte{}
		} else {
			return err
		}
	}

	ignoreContent := string(gitIgnore)

	// Define the section markers for the sync patterns
	sectionStart := "# SYNCWAVE START"
	sectionEnd := "# SYNCWAVE END"

	// Generate the new content for the SYNCWAVE section
	newSection := fmt.Sprintf("%s\n# WARNING: This section is generated by the syncwave app.\n", sectionStart)

	for _, file := range syncConfig.Patterns {
		log.Println("Adding file to .gitignore:", file)
		newSection += file + "\n"
	}
	// err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
	// 	if err != nil {
	// 		return err
	// 	}
	// 	if matchesSyncPattern(path) {
	// 		return nil
	// 	}
	// 	if checkFileSize(path) {
	// 		log.Println("Adding file to .gitignore:", path)
	// 		newSection += path + "\n"
	// 	}
	// 	return nil
	// })
	// if err != nil {
	// 	fmt.Println("Error finding matching files:", err)
	// }
	newSection += sectionEnd + "\n"

	// Regular expression to match the existing SYNCWAVE section
	sectionRegex := regexp.MustCompile(`(?s)# SYNCWAVE START.*?# SYNCWAVE END`)

	// Replace the SYNCWAVE section if it exists, or append it if not
	if sectionRegex.MatchString(ignoreContent) {
		ignoreContent = sectionRegex.ReplaceAllString(ignoreContent, newSection)
	} else {
		// If the section doesn't exist, append it at the end of the file
		if !strings.HasSuffix(ignoreContent, "\n") {
			ignoreContent += "\n" // Ensure there's a newline at the end
		}
		ignoreContent += newSection
	}

	// Write the updated content back to the .gitignore file
	return ioutil.WriteFile(".gitignore", []byte(ignoreContent), 0644)
}

func removePreviousZipFiles(branch string) error {
	files, err := ioutil.ReadDir(syncConfig.CloudDir)
	if err != nil {
		return err
	}

	for _, file := range files {
		if strings.HasPrefix(file.Name(), branch+"_") && strings.HasSuffix(file.Name(), ".zstd") {
			err := os.Remove(filepath.Join(syncConfig.CloudDir, file.Name()))
			if err != nil {
				return err
			}
		}
	}

	return nil
}
